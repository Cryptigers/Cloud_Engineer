Sysfs devfs udev
	Ядро операционной системы обращается не напрямую к оборудованию, а через его виртуальное представление: HAL (hardware abstraction level). Ядро обращается к HAL, он выбирает драйверы и общается с железом. Сейчас не HAL, а Udev. Dbus - предоставляет информацию о железе. Udev - интерактивный, HAL - нет. 

	Devfs - использовавшаяся  в прошлом виртуальная файловая система (находится в оперативной памяти), функционал которой перешел в Udev. Монтируется в /dev. Файлы устройств не на жестком диске, а в оперативке. 
		- mem		образ физической памяти ПК (слепок оперативки);
		- null 		пустое устройство;
		- pts/ 		псевдотерминалы;
		- urandom	генератор случайных чисел (можно использовать для создания ключей);
		- sdx		блочные устройства (жесткие диски, USB накопители);
		- tty		аппаратные терминалы (устройство пользовательского интерфейса ввода).

	Sysfs - тоже виртуальная файловая система. Выводит на уровень пользователя информацию от ядра об устройствах и драйверах. Монтируется в /sys. Также перекочевала в udev.
		- devices/	все устройства, зарегистрированные в ядре;
		- bus/		перечень шин;
		- drivers/ 	драйверы;
		- block/	каталог блочных устройств;
		- class/	группировка устройств по классам. 

УПРОЩЕННО: sysfs - то, что мы видим снаружи, devfs - содержимое и то, что внутри.

	Procfs - также виртуальная файловая система иерархически представляет все запущенные процессы в системе. Монтируется в /proc. 
		- PID/		информация о конкретном процессе;
		- cpuinfo/	сведения о ЦПУ;
		- devices/	перечень настроенных устройств;
		- mounts/ 	смонтированные файловые системы;
		- sys/ 		доступная для редактирования информация о системе.

Procfs - предоставляет метод обращения обмена информацией между ядром и пользователем. 

Изменения в виртуальных файловых системах происходят «на лету» и не сохраняются после перезагрузки системы. Если мы хотим внести постоянные изменения (пример - ip forwarding) необходимо вносить изменения в загрузку ОС (инициализацию системы).

Обращаясь (запуская) файл устройства, как правило, мы обращаемся к драйверу этого устройства.

	htop - диспетчер задач
	ip addr - покажет IP, сетевую карту
	ifconfig	


2. Обнаружение и управление устройствами.
	lsmod 		информация о модулях ядра;
	lspci		информация о модулях pci;
	lsusb		информация о шине usb;
	lscpu		информация о ЦПУ.

 У udev есть своя утилита udevadm, у нее есть несколько опций:
	info		получение информации из БД;
	trigger		запросить события для устройства;
	settle		дождаться завершения обработки;
	control		управление демоном;
	monitor	следить за событиями;
	test 		симулировать запуск события.

Модули ядра - программный объект, содержащий код и расширяющий функционал ядра. 	

	udevadm test /sys/block/sda 	Udev, покажи мне события которые могут происходить с 						блочным устройством sda.

 Управление модулями ядра.
	lsmod 		информация о модулях ядра;
	modinfo	информация о конкретном модуле;
	rmmod		удаление модуля ядра;
	insmod	установка модуля ядра;
	modprobe	деликатное удаление и добавление модулей.


3. Загрузка системы.

Общий процесс:
	- После включения компьютера центральный процессор переходит на адрес BIOSа (в современных компах UEFI), который проводит кучу проверок и согласно своим настройкам выбирает источник загрузки; 
	- На носителе находится либо MBR (Master Boot Record), или GPT (GUID Partition Table - в современных компах) - это первые 512 байт кода на жестком диске;
	- Далее загрузчик либо сразу загружает ОС (стадия Linux Kernel), либо передает управление следующему загрузчику (LILO, GRUB) (если на нескольких разделах жесткого диска установлены Linux и Windows);
	- Далее загружается пользовательская среда (Init). Init - первый, родительский процесс. Запускает все остальные.

dmesg 		Сама команда выводит все сообщения ядра, а её лог находится в: /var/log/dmesg	содержит только события загрузки
pstree			Показывает дерево всех запущенных процессов (родительский init)
cd /boot 		Папка загрузчика, в ней можно увидеть какой загрузчик (папка grub), 				файлы ядра и образы init run disc (создается в оперативке и содержит 				файлы, которые необходимы ядру Linux для его корректной загрузки).

4. Инициализация в стиле SysV (до CentOS 6).

Runlevel (уровни выполнения): 
0 - выключение
1 - однопользовательский режим
2 - Debian/Ubuntu по умолчанию
3 - RedHat/Suse по умолчанию текстовый режим
4 - WildCard (программируемый режим - можем поставить туда все, что захотим)
5 - RedHat/Suse - GUI
6 - перезагрузка

Все эти уровни выполнения по-сути являются запускаемыми скриптами (хранятся в /etc).
rc1.d-rc7.d - в них прям перечень скриптов с номером загрузки в названии.

В уже загруженной системе командой # telinit 1 (номер runlevelа) можно перевести систему в необходимый нам режим.

команда wall «text» 	текстовое сообщение от рута всем юзера.

5. Инициализация системы в стиле systemd.

Systemd работает с Unit`ами (модулями):
	- .service	службы;
	- .mount	точки монтирования;
	- .device	устройства;
	- .socket	сокеты

/usr/lib/systemd	директория с юнитами по умолчанию;
/etc/systemd		директория с управляемыми юнитами (которые может редактировать 				юзер). В этой библиотеке находятся конфигурационные файлы, 					которые пришли на замену inittab.
	Управление демоном systemd происходит с помощью утилиты systemctl, например: 	systemctl list-units	покажет все запущенные юниты (используемые устройства, службы, точки монтирования, сокеты);
	systemctl —failed	покажет юниты, которые не запустились

# 
Вот хороший мануал: http://unix.stackexchange.com/questions/47695/how-to-write-startup-script-for-systemd
По сути для сложных ситуаций вам надо создать обычный скрипт, затем для него юнит (типа .service) и поставить этот юнит в автозагрузку. Для простых ситуаций - просто создать новый юнит с командой в его теле, и также в автозагрузку.

Тут теперь подход в корне другой ведь. Нужно смотреть юниты (в данном случае службы) и таргеты (которые вместо runlevel). то есть глядеть ссылки на какие службы есть в каких таргетах. И для всего этого использовать systemctl

Добавить или убрать юнит из автозапуска при загрузке системы:
# systemctl enable юнит
# systemctl disable юнит
#

Таргеты - иногда аналоги ранлевелов в sysV, они не пронумерованы, а имеют конкретные имена. 
0	poweroff.target	выключение
1	rescue.target		однопользовательский режим
2, 4	multi-user.target	настраиваемые режимы
3	multi-user.target	многопользовательский режим
5	graphical.target	графика
6	reboot.target		перезагрузка

systemctl list-units —type=target	узнать запущенные таргеты
systemctl isolate name.target		переключиться на другой
systemctl set-default -f name.target	установить по умолчанию

journald	служба журналирования (просмотр диагностической информации)
управляется журнал командой:
	journalctl  -f 		события в потоке
	journalctl -n 10	последние 10 событий
	journalctl _UID=0	события по UIDу

Преимущества Systemd: более быстрая загрузка за счет использования параллельных потоков, более надежная загрузка, потому что если один сервис подвиснет или не загрузится - остальные не будут его дожидаться, умеет не просто параллельно загружать сервисы, но и отслеживает их состояние и даже исправляет ошибки, более надежная система последовательности, прекрасная система журналирования.

6. Работа с жесткими дисками в Linux.

Следующие файлы и папки могут быть смонтированы как отдельные разделы жесткого диска:
	/	корневая файловая система, самый большой раздел;
	/boot	загрузочный раздел; (хороший тон - создавать первым разделом около 100мб)
	/home	домашние папки; (можно монтировать как сетевую папку, чтобы везде была одна рабочая среда можно хранить домашнюю папку на сервере и просто примонтировать юзера к домашней папке с каждым линуксом за которым он будет работать)
	/root	домашняя папка суперпользователя; (как правило тоже хранится на отдельном разделе)
	/etc	файлы конфигураций системы и её компонентов; (иногда хранится на серверах)
	/opt	папка для ПО третих поставщиков;
	/var	часто меняющиеся данные; (имеет смысл использовать SSD диски)
	/usr	все установленные пакеты программ, документация, исходный код ядра; (чаще всего для чтения, может быть использована на медленном диске)
	/tmp	временные файлы;

	swap 	раздел подкачки. Никуда не монтируется. Подкачка - раздел на жестком диске, который может использоваться при переполнении оперативной памяти.

Sda 		жесткие диски (vda - виртуальные в облаке)
Fdisk -l	лист существующих дисков и разделов
fdisk /dev/sda		После выбора устройства (в данном случае sda) будет много ключей, 				которые позволяют работать с жестким 	диском. Создавать новые 					разделы, расширенные разделы (системы позволяют 4 раздела, но 					можно создать расширенный, в которой 	можно добавить еще). 
Но созданные разделы нельзя использовать, потому что они не отформатированы, для этого:

fdisk /dev/sda далее ключ t , пишем номер раздела id из fdisc -l и выбираем системный тип раздел из списка. Но разделами все еще нельзя пользовать, форматируем:

mkfs.ext4 /dev/sda2		  отформатировать раздел sda2 в ext4

 Работа  подкачки: 
swapon и swapoff		команды работы с разделом подкачки
mkswap			утилита создания раздела или файла подкачки

/etc/fstab	конфигурационный файл, за монтирование файловых систем

LVM - системы управления томами для Линукс.  Позволяет поверх физических разделов создать логические разделы - тома. 

https://help.ubuntu.ru/wiki/lvm

7. Загрузчики Linux.

При использовании MBR необходимо делать резервную копию этой части жесткого диска (512 байт)
Первый и самый популярный загрузчик был LILO (Linux Loader);
Потом был GRUB Legacy (не поддерживается, даже невозможно установить);
Сейчас GRUB2 (конфиг создается сам, файлы ядра обнаруживает сам). Действия загрузчика определяются скриптами в папке /etc/grub.d которые написаны на shell. В целом GRUB автоматический и сам все прописывает.

8. Управление библиотеками в Linux.

Библиотеки - набор функций, которые можно использовать с различными программами. Библиотеки могут быть статичными (когда софт содержит в своем теле) и динамичными (когда библиотеки грузятся в оперативную память и используются).
Статические без проблем совместимости, библиотеки всегда с собой, но программы становятся тяжелыми.
Динамические уменьшают размер программы, а также однажды загруженная библиотека позволяет быстро загружаться другим программам.

Хранятся: 	/lib		библиотеки тут используют программы, расположенные в /bin
		/usr/lib		используют /usr/bin

ls | (pipeline) grep ld.	отсортировать результаты, чтобы показал все, что содержит ld.

 Чтобы определить какими библиотеками пользуется программа команда: ldd /bin/ls (необходимо указать путь к бинарнику).

9. Управление пакетами в Debian-подобных ОС. 

Dpkg	утилита управления пакетами в Дебиан системах:
l	перечень пакетов в системе
L	перечень файлов в системе
s	информация о статусе пакета
S	поиск пакета, содержащего файл
i	установка пакета
I	информация о пакете в файле *.deb
r	простое удаление пакета
P	удаление пакета вместе с конфигами

Dpkg-reconfigure	переконфигурация пакета

Упрощенное управление пакетами ‘apt’ или ‘aptitude’

Apt 	Advanced packaging tool. Программа работы с пакетами программ в Дебиан системах:
apt-get		для скачивания и установки пакетов
apt-cache	для поиска пакетов
aptitude	полное управление пакетами с опцией псевдографики

/etc/apt/sources.list	перечень репозиториев

apt-cache depends zabbix	покажет от каких пакетов зависит Заббикс

Репозитории: 	main		официальные от разработчиков
			restricted	частично-свободное ПО
			universe	дистрибутивы от коммьюнити
			multiverse	nonfree, не поддерживает открытое ПО

10. Управление пакетами в RedHat подобных ОС.

Rpm	утилита управления пакетами в RedHat системах:
rpm -qi zabbix		подрбоная информация о пакете

rpm2cpio filename.rpm > filename.cpio	конвертация файла из .rpm в стандартный для unix систем .cpio

yum	
В Центосе репозитории хранятся иначе, чем в Дебиан:
cd /etc/yum.repos.d/ Чтобы добавить свой репозиторий - нужно добавить в эту директорию.

11. Работа в командной строке.

Настройки программируемой оболочки Bourne again Shell (BASH) находятся в файле etc/profile

env	показывает переменные среды

echo $ABC	знак $ означает, что обращаемся к переменной

export		создание переменной
unset		уничтожение переменной

uname -a 	покажет детально какая ОС

file filename	покажет информацию о файле (расширение и прочее)

whatis vim	покажет информацию об объекте

history		покажет историю выполненных команд

man history	мануал по работе с объектом

exec ls -a	выполнить команду минуя оболочку пользователя

12. Работа с текстовым выводом в Linux.

cat		может выводить текст на экран, или переводить в другие файлы
cut		удаляет секции в выводе из каждой строчки файла (не изменяет файл)
expand	преобразует tabы в пробелы
fmt		преобразует вывод (с помощью разных ключей). Можно просматривать 				удобно логи по абзацам.
head		показывает первую часть файлов (по-умолчанию 10 строк)
head -n 2 filename	покажет 2 строчки

od		конвертатор
join		объединяет строчки файлов по общему полю (удобно для слияния логов по 			полю времени)
less		просмотр текста с постраничным перелистыванием. Удобная команда вывода
nl		нумерует строки
paste		умеет построчно объединять строки файлов (не как join)
pr		показывает как будет выглядеть текст при выводе его на печать
sed		stream editor потоковый редактор для фильтрации и трансформирования 				текста. Практически полноценный текстовый редактор (но только для 				вывода). Сложный, нужно изучить в man sed 
https://www.opennet.ru/docs/RUS/bash_scripting_guide/a14586.html

sort		сортирует строки в текстовых файлах по какому-либо признаку
split		бьет файл на куски (в выводе) 
tail		показывает последнюю часть файла (как head, только наооборот)
tail -n 5 filename	покажет последние 5 событий
tr		переводит или удаляет символы (можно удалить капс лок в тексте, удалить 			буквы, объединить соседние буквы в одну и тп - можно посмотреть в 				мануале)
unexpand	превращает пробелы в табы	
uniq		ищет уникальные и дублирующиеся линии (посмотреть уникальные строки, 			показать дублирующиеся строки и сколько раз)
wc		word count показывает количество символов, байт, слов, строк


13. Основные операции с файлами.

touch		создать файл
mkdir		создание директории
cp		копирование файлов и папок. Ключ -R скопирует рекурсивно (например 				директорию с вложенными файлами).
mv		перенос и/или переименование файлов
rm		удаление файла. Если директория с содержимым то с ключом -r

Групповые символы:
*	все, что угодно
?	любой символ
!	не
[ac]	а или с
[a-c]	a,b,c


find		поиск файлов
dd		конвертирует и копирует файлы. Может копировать блочные устройства, 				например диск (dd if=/dev/sdb of=drive.img)
gzip/gunzip 	заархивировать/разархивировать
bzip2/bunzip2	заархивировать/разархивировать (сжимает сильно эффективнее чем gzip)
xz/unxz	заархивировать/разархивировать
tar		наиболее часто используемый архиватор. Может использовать и другие 				архиваторы (tar cvfz filename.tar.gz foldername)
tar xvf		разархивировать

14. Использование потоков, конвейеров, перенаправлений.


stdin (0)	ввод
stdout (1)	вывод
stderr (2) 	вывод ошибок
>		передать в
>> 		дописать в
<		взять из
|		отправить следующей команде
Tee		оправить в файл и на стандартный вывод
Xargs		построчно передать на ввод команде

Конвейер - умеет передавать выходные данные из одной программы как входные для другой. То есть выполняется результат команды и идет куда-то дальше. 
ls | grep r
выдаст файлы, содержащие r. То есть выполняется list, потом выполняется сортировка grep.

ls | tee output.txt	выдача list и на вывод, и в файл output.txt

15. Работа с процессами.

sleep 1000		компьютер уснет на 1000 секунд
sleep 1000 &		компьютер уснет на 1000 секунд в фоновом режиме
jobs			покажет выполняющиеся задачи (с нумерацией процессов)
fg 1			1- номер процесса из jobs. Переведет процесс из фона в вывод
bg 1			1- номер процесса из jobs. Переведет процесс в фона

ps			снэпшот текущих процессов (популярный ключ aux)
ps aux | grep processname	
kill 1111		убить процесс по номеру процесса из ps aux
nohup 			чтобы процессы не завершались при выходе пользователя из системы
pstree			дерево процессов
top			показывает все процессы, сортировка по загруженности. Кнопками < 				> можно менять сортировку. Если ввести k, вводим id процесса и 					убиваем его.
uptime			покажет как долго запущена система
free			покажет количество свободной памяти
screen			создает второе окно терминала

16. Приоритеты процессов.

Приоритеты бывают от -20 до +19
-20 - максимальный приоритет, +19 - минимальный приоритет

Выставляется приоритет командами Nice и Renice
например по-дефолту процесс с nice sleep 10000 будет запущен с приоритетом 10 (обычно запущенный процесс запускается с 0), то есть с приоритетом ниже стандартного. 
Например команда renice 15 -u nameuser	и все задачи юзера будут деприоритезированы 
renice позволяет изменить приоритет уже запущенной задачи.

17. Регулярные выражения.

grep		утилита поиска по выражению (понимает некоторые регулярные выражения)
egrep		расширенный grep (понимает все регулярные выражения)
fgrep		быстрый grep (не понимает регулярных выражений)
rgrep		рекурсивный grep (ищет во всех вложенных файлах и папках)
sed		потоковый текстовый редактор для фильтрации и трансформации текста

18. Текстовый редактор Vi

19. Создание и форматирование разделов жестких дисков.

fdisk
gdisk
parted	
gparted
mkfs
mkswap

mkfs -t (тип файловой системы) ext2 /dev/sdb1	отформатируй под ext2 устройство sdb1
mkfs -t ext3 /dev/sdb1	отформатируй под файловую систему ext2 устройство sdb1
mkfs -t xfs /dev/sdb1		скорее всего напишет, что такого файла нет, тогда:
	apt-cache search xfs
	apt-get install xfsprogs
mkfs -t reiserfs /dev/sdb1
mkfs -t btrfs /dev/sdb1	линуксовая файловая система от Oracle

parted		используется для разбиения дисков более 2ТВ. Изменения происходят сразу. 		Обширный функционал с множеством ключей.

20. Проверка файловой системы

df -h		показывает состояние использование дискового пространства

Индексные дескрипторы в журналируемых файловых системах - айноды. Айноды - метка, идентификатор файла. В них хранится информация о владельце, типе файла, правах доступа. Для каждого файла - своя айнода. По-сути - показывает нахождение на жестком диске.

df -i 		показывает информацию по айнодам

du		показывает сколько места занимает размер папок в текущей директории
du -h		покажет в нормальном виде (мб, гб) 
fsck 		filesystem check проверяет целостность файловой системы
debugfs 	отладчик файловых систем (чистит, удаляет, исправляет ошибки фс, работает 		с айнодами)

командой rm filename мы удаляем файл (команда ls не покажет наличие этого файла). При этом через debugfs видно, что количество объектов не изменилось. До тех пор пока на место этого файла не будет записана новая информация - этот файл можно восстановить. При удалении удаляется не сам файл, а его индексный дескриптор, его метку. Сам файл остается на жестком диске. Поэтому всю информацию в журналируемых файловых системах можно восстановить восстановив индексный дескриптор. Если случайно пропали файлы - нужно выключить компьютер и вытащить жесткий диск, чтобы данные не перезаписались. 

debugfs: lsdel 			покажет лист удаленных индексных дескрипторов
debugds: undel <12>	filename	указать номер дескриптора, который мы хотим 								восстановить
dumpe2fs /dev/sdb1			делает дамп 
tune2fs				настраивает файловую систему. Например:
tune2fs -O has_journal /dev/sdb1	превращает фс e2fs в журналируемую

21. Монтирование и демонтирование файловых систем.

Монтирование - это подключение разделов жесткого диска, внешних съемных носителей, прочих файловых систем, которые могут находиться на носителях информации. Получение к ним доступа, отключение их автоматическое и вручную.

Точка монтирования - пустой каталог в файловой системе. Если в корне есть папка mnt - то монтируют в неё все нужные новые файловые системы. В папку media монтируют сменные носители.

	mount /dev/sdb1 /mnt/hard_drive	устройство sdb1 было смонтировано в папку 								hard_drive

	mount			покажет все примонтированные фс 
	umount /dev/sdb1	отмонтирует устройство
	/etc/fstab		в нем находятся настройки автоматического монтирования 						файловых систем	
Подключение нового устройства:
	vi /etc/fstab		открываем файл fstab для внесения измений
далее пишем строку:
	/dev/sdb1 (имя жесткого диска)	/mnt/hard_drive (где монтируется)	auto (файловая система)	defaults (чтение, запись, user (кто может монтировать), auto (автоматически подключать при запуске компьютера))	0	2

	blkid /dev/sdb1	покажет ID устройства, который можно будет написать в файле 					fstab вместо имени диска (sdb1)

22. Управление квотами дисков.

В файле fstab указываем доп настройки quota. Вероятно нужно поставить apt get quota

можно установить мягкую и жесткую квоты на пользователя. Сколько пользователь сможет использовать блоков на диске.

23. Владельцы файлов и папок.
 
chown		установка владельца		chown username filename
chgrp		установка группы владельцев	chgrp groupname filename
chmod		установка прав доступа		
ключ -R сразу после команды - рекурсивно означает, что команда будет действовать не только в отношении объекта указанного в команде, но и на все объекты внутри этого объекта.

chmod u+x	добавить права execute user`у в текущей директории
x eXecute	для директорий необходимо чтобы открыть папку.

Маски создания файлов и папок
	umask		маска создания файлов и папок (какие права создаются по-дефолту)
	suid		бит запуска от имени владельца
	sgid		бит запуска от имени группы владельцев
	sticky		бит защиты содержимого

Выглядят как еще одна цифра перед цифрами прав (4 Suid бит прибавляется к правам пользователя, 2 sgid бит прибавляется к правам группы, 1 sticky бит прибавляется к правам остальных пользователей). 
	Либо:	chmod u+s filename
		chmod g+s filename
		chmod o+t filename

	umask 022	означает, что все файлы и папки будут создаваться с разрешением 					777-022=755 (то есть rwxr-xr-x)
	umask 754	означает, что все файлы и папки будут создаваться с разрешением 					777-754=023 (то есть ——-w—wx)



grep umask /etc/profile	узнать какой профиль прав при создании файлов и папок по-						умолчанию

24. Мягкие и жесткие ссылки

Hardlink использует ту же айноду, имеет тот же размер, что и оригинал файла. Нельзя создавать на каталоги.
Softlink использует другую айноду, но весит меньше (как ярлык). Опираются на полное имя файла. При переименовании оригинала теряет связь.

	ln file newfile		hardlink
	ln -s file newfile	softlink

25. Поиск и расположение команд и файлов

 FHS:
/bin		базовые бинарники команд
/boot		файлы загрузчика
/dev		устройства
/etc		конфигурация ПК
/home		домашние папки
/lib		библиотеки и модули ядра
/proc		информация о работающей системе
/media		монтирование носителей
/mnt		старая папка - в нее раньше монтировались съемные носители
/opt		дополнительное ПО
/root		домашняя папка рутаLocate
/sbin		основные программы настройки системы (init, iptables)
/srv		данные для системных служб
/tmp		временные файлы		
/usr		бинарники файлы пользователей
/var		переменные

Grep		утилита поиска по содержимому
Find		утилита поиска файлов по свойствам
Locate		быстрый поиск файлов (но перед поиском надо сделать sudo updatedb)
Which		поиск команды (пример: which ls)
Type		вывод точной команды
Whereis	поиск команды, исходников и мануала




 




